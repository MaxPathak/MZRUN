#ifndef ENGINE_H
#define ENGINE_H

class Engine {
private:
	Save data;
	char paths[50][50];
	bool gameOver;
	unsigned int timer;
	Object *player;
	inline int tick() {	return timer/TICKSPEED;	}

public:
	Engine();
	~Engine() {}
	void drawEngine();
	void inputEngine();
	void handleEngine();
	void HUD();
	int getPaths(char paths[][50]);
	inline bool getState() {	return gameOver;	};
	inline unsigned int getTimer()	{	return timer;	}
	inline Object* getPlayer()	{	return player;	}
};

Engine :: Engine() {
	srand((unsigned)time(0));
	gameOver = false;	timer = TICKSPEED * TIMELIMIT;
	player = &entityObjects[0];

	int gen = rand() % getPaths(paths);
	this->data.Import(strcat("./MZRUN/LEVELS/", paths[gen]));
}

void temp() {
	int i, j;
	gotoxy(37,10);
	for(i=1; i<=10;i++) {
		if(i==1)	cprintf("%c", border[2]);
		else if(i==10)	cprintf("%c", border[3]);
		else	cprintf("%c", border[0]);
	}
	for(j=1; j<4; j++) {
		gotoxy(37,10+j);
		for(i=1; i<=10;i++) {
			if(i==1 || i==10)	cprintf("%c", border[1]);
			else	cprintf("%c", ' ');
		}
	}
	gotoxy(37,14);
	for(i=1; i<=10;i++) {
		if(i==1)	cprintf("%c", border[4]);
		else if(i==10)	cprintf("%c", border[5]);
		else	cprintf("%c", border[0]);
	}
	getch();
	exit(0);
}

void Engine :: HUD() {
	int i, j;
	{	//Map Window
		for(i=1; i<=25; i++) {
			gotoxy(screen.x+boardX,i);	printf("%c", 179);
		}
		for(i=1; i<=screen.x+boardX;i++) {
			gotoxy(i,screen.y+boardY);	printf("%c", 196);
		}
		gotoxy(screen.x+boardX,screen.y+boardY);	printf("%c", 180);
	}

	gotoxy(2, 24);	printf("Timer: ");
}

void Engine :: drawEngine() {
	int i, j;
	coord camera = view(player->getPos(), screen, *fullmap);
	for(i = 0; i<screen.y; i++) {
		for(j = 0; j<screen.x; j++) {
			gotoxy(boardX+j, boardY+i);
			//Vision
			/*if(player->distance(camera + coord(j, i)) > torchRange) {
				blackair.draw();
				continue;
			}*/
			int obj = posCheck(camera + coord(j, i));
			if(obj!=-1)	entityObjects[obj].draw();
			else if(goal.getPos() == coord(j, i))	goal.draw();
			else if(map[camera.y + i][camera.x + j].isBlocked()) wall.draw();
			else	air.draw();
		}
	}
	gotoxy(8, 24);
	printf("%3d", timer/TICKSPEED);
}

void Engine :: inputEngine() {
	if(kbhit()) {
		switch(getch()) {
		case 'w':   player->moveObject(+0, -1);	break;
		case 's':   player->moveObject(+0, +1);	break;
		case 'a':   player->moveObject(-1, +0);	break;
		case 'd':   player->moveObject(+1, +0);	break;
		case 'x':   gameOver = true;			break;
		}
	}
}

void Engine :: handleEngine() {
	int i;
	//gotoxy(1, 25);	cprintf("%5u",timer);	
	//Death
	/*if(posCheck(player->getPos(), "monster")) {
		drawEngine();
		player->death();
		gameOver = true;	return;
	}*/
	//Win
	if(player->getPos() == goal->getPos()) {
		drawEngine();
		player->death();
		gameOver = true;	return;
	}
	for(i = 1; i<totalEntities; i++) {
		entityObjects[i].route(timer);
	}
	if( this->tick() < 1 )
		gameOver = true;
	timer--;
}

int Engine :: getPaths(char paths[][50]) {
	struct dirent *de;
	DIR *dr = opendir("./MZRUN/LEVELS");
	if(dr == NULL) return 0;
	int cnt=0, s;
	char* name;	char* ext = ".LVL";
	while((de = readdir(dr)) != NULL)  {
		s = strlen(de->d_name);
		for(int i=s-4; i>0; i--)
			if(de->d_name[i] != ext[s-4-i])	continue;
			else {
				strcpy(paths[cnt++], de->d_name);
			}
	}
	closedir(dr);
	return cnt;
}

#endif